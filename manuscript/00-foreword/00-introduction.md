# Introduction

State management in web applications has become a popular topic in the recent years. [Single page applications (SPAs)](https://en.wikipedia.org/wiki/Single-page_application) - that are only delivered once from a web server yet stay interactive on the client - have to establish state management on the client. They have to keep the state consistent in the frontend application without making any more requests to the backend application. They have to give the user an effortless and pleasant experience when using the application. It already starts when opening a popup in your application. It should be possible to open and close it. So someone has to be aware of this state. But who manages this state if it is not the backend application?

[jQuery](https://en.wikipedia.org/wiki/JQuery) was a popular library before the first SPA solutions, such as Angular, Ember, and Backbone appeared. State management itself wasn't a huge problem in jQuery in the beginning, because the library was most often only used for selective DOM manipulations. You could add animations to your HTML, add or remove DOM nodes or change the style of your HTML programatically. It made web application more enjoyable by making them interactive.

Eventually, the jQuery code, and in general the portion of JavaScript code in contrast to HTML and CSS grew, and people wrote more sophisticated frontend applications. Most of the time, it ended up in a mess of jQuery code where not only state management was a problem, but also general best practices like clean code were missing. There was no solution of a general architecture for these kind of frontend applications and people struggled to keep it maintainable in larger applications.

After a while, single page application (SPA) solutions like Angular, Ember and Backbone emerged to give these unstructured frontend applications a proper architectural framework. The greater part of the SPAs build up on the [model-view-controller (MVC) pattern](https://en.wikipedia.org/wiki/Model-view-controller) to architect the application. The mentioned frameworks contain everything you would need, from a view layer for displaying HTML in the browser to a model layer for interacting with your backend, to build your sophisticated application. The term SPA was coined, because these applications are only served once from the web server, as a single page, but then operate only on the client-side. They are blobs of HTML linked to JavaScript which contain everything the applications needs to work on the client-side. When navigating to a different page under a different URL, there is no additional server request required to fetch the HTML with JavaScript. SPAs only interact with the backend to pull or push new data from or to it. Thus, the only thing that changes is the state inside the client-side application, because data is read and written to and from the backend and interactions such as popups, filters and modals have to work. But who manages this state to keep the client-side consistent?

Even though these frameworks for SPAs established best practices, patterns and architectures for the first generation of SPAs, state management became a recurring issue for them. When interacting with the backend to retrieve new data, it was unclear how to manage the data in a predictable way. When triggering view related elements, such as modals or popups, in the frontend, often there wasn't established best practice to manage these states. Every framework tried to apply their own solution for it. Eventually, people came up with their own best practices and libraries, but it never became a predictable and consistent experience to manage state with clear constraints.

There was one major flaw with these SPA solutions that led to this problem in the first place: As frameworks, they tried to solve too many issues at once. Because they were the first of their species, they hadn't the chance to solve all issues in the world of SPAs. Eventually, they solved these issues in another iteration when other SPA solutions appeared at the scene.

The second generation of SPA solutions, among them libraries like React and Vue, focused only on smaller parts of the application. They focused on the view layer. It was up to the engineer to decide on additional libraries as solutions for specific problems. [That's what made React such a powerful library in the first place](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), because everyone could decide to extend their application with libraries that solve specific yet small problems.

Nowadays, a ton of articles and libraries try to solve the issue of state management. It is difficult to find a consistent source of truth to learn state management in modern applications. Even though, solutions like React have their own state management implementation for local state in components, there are more external solutions coming as libraries such as Redux and MobX that establish sophisticated state management.

Still, it lacks one guide to navigate through all these different solutions to make the differences and benefits of state management clear. Quite often, the guides miss the point of teaching the problem first. In addition, instead of showing the minimal approach, they try to fix the problem of state management by using over-engineered approaches. But it can be so much simpler. It only needs one resource to guide through state management in modern applications in a consistent and constructive way. And that's the mission of this book.

If you want to learn something, you have to do it step by step. Trying to solve each atomic problem after the next one. Don't apply everything at once. Understand the problem and solve it. That's my attempt with this book: It doesn't only teach Redux in React, but state management in modern applications. It goes beyond the documentation of state management libraries, but applies the learnings in real world applications in the book.

These are the heroes of the book: Local State (in React), Redux and MobX. It wouldn't have been possible to write the book without the innovators behind these solutions: [Dan Abramov](https://twitter.com/dan_abramov), [Andrew Clark](https://twitter.com/acdlite) and [Michel Weststrate](https://twitter.com/mweststrate). I guess, I can thank them in the name of the community for their efforts to make state management in modern applications a consistent and enjoyable experience.