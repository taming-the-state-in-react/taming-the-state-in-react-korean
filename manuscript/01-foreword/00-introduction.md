# 1. 시작하는 글

최근 몇 년간 웹 애플리케이션 내 상태 관리(state management)는 가장 많이 회자되고 있는 주제 중 하나입니다. [단일 페이지 애플리케이션(SPAs, single page applications)](https://en.wikipedia.org/wiki/Single-page_application)은 웹 서버에서 데이터가 전달된 이후 클라이언트에서 대화형으로 유지됩니다. 클라이언트에서 상태 관리를 처리합니다. 즉 백엔드 애플리케이션에 요청하지 않고 프론트엔드 애플리케이션에서 상태가 일관적으로 유지되어야 합니다. 사용자 경험은 쉽고 즐거워야 합니다. 애플리케이션을 처음 켤 때부터 말이죠. 팝업 창이 열고 닫는 것이 쉬워야 합니다. 팝업 창이 바로 상태(state)입니다. 그렇다면 백엔드가 아닌 누가 이 상태를 관리할까요?

[제이쿼리(jQuery)](https://en.wikipedia.org/wiki/JQuery)는 앵귤러(Angular), 엠버(Ember), 백본(Backbone) 등 SPA 출현 이전 가장 유명한 라이브러리 중 하나였습니다. 초기에 제이쿼리는 DOM 조작을 다루기 때문에 제이쿼리 내 상태 관리는 큰 문제는 아니였습니다. 제이쿼리로 인해 HTML에 애니메이션을 추가하기 위해 DOM 노드를 추가하거나 삭제하거나, HTML 내 스타일을 바꾸는 작업 등 인터렉티브 한 웹 개발이 가능해졌습니다. 

결국 HTML과 CSS보다 제이쿼리와 자바스크립트 비중이 커졌고 더 정교한 프론트엔드 애플리케이션이 등장했습니다. 상태 관리는 물론 클린 코드와 같은 모범 사례가 없었기에 대다수 애플리케이션 개발에서 제이쿼리 코드는 엉망이었습니다. 프론트엔드 애플리케이션 아키텍처 솔루션도 없었습니다. 때문에 규모가 큰 애플리케이션을 유지 보수할 수 있는 방법이 필요했습니다.

이후 SPA 개발을 위해 비구조화된 프론트엔드 애플리케이션 아키텍처 프레임워크이 등장했습니다. 바로 앵귤러(Angular), 엠버(Ember), 백본(Backbone)입니다. SPA의 핵심은 [model-view-controller(MVC) 패턴](https://en.wikipedia.org/wiki/Model-view-controller)을 기반으로 애플리케이션을 구성하는 것입니다. 이 프레임워크는 브라우저에서 HTML을 표시하는 뷰(view) 레이어부터 백엔드와 상호 작용하는 모델(model) 레이어에 이르기까지 필요한 모든 것을 제공하기 때문에 보다 정교한 애플리케이션을 만들 수 있게 되었습니다. SPA란 웹 서버에서 받은 정보를 한 페이지 내에서 클라이언트에서 조작하는 것을 말합니다. 자바스크립트와 연결된 HTML 덩어리는 클라이언트에서 모두 처리됩니다. 다른 페이지로 이동할 때 자바스크립트로 HTML을 가져오는데 서버에 추가 요청을 보내지 않습니다. SPA는 새 데이터를 가져오거나 보낼 때만 백엔드와 상호 작용합니다. 팝업, 필터 및 모달 창과 같은 인터렉션은 클라이언트 내부 상태에서 처리합니다. 그렇다면 클라이언트에서 누가 상태를 일관성 있게 처리하는 걸까요?

SPA 프레임워크 1세대의 출현으로 SPA의 모범 사례, 패턴 및 아키텍처가 구축됐지만 상태 관리는 여전히 문제였습니다. 새로운 데이터를 검색하기 위해 백엔드와 상호 작용할 때 예측 가능한 방식으로 데이터를 관리하는 방법이 일반화되지 않았습니다. 프론트엔드에서 모달 또는 팝업 창과 같은 뷰 요소를 조작할 때 상태를 관리할 수 있는 범용적인 모범 사례도 정해지지 않았습니다. 프레임워크마다 저마다 각기 다른 솔루션을 도입했고 모범 예제를 제안하고 대체 라이브러리를 만들었지만 상태 관리 방법이 명확하지 않았습니다.

이는 초기 SPA 프레임워크에서는 많은 일을 한꺼번에 해결하고자 했기 떄문에 상태 관리와 같은 문제가 생긴 것입니다. 처음 시작하는 단계였기 때문에 SPA 생태계에서 충분희 의논하고 해결할 기회가 없었기도 합니다. 결국 다른 SPA 솔루션이 등장할 때마다 상태 처리 문제를 해결하려 했습니다.

SPA 2세대인 리액트(react)와 뷰(Vue) 라이브러리는 애플리케이션의 작은 부분인 뷰 레이어만 집중했습니다. 상태 관리와 같이 특정 문제를 해결하기 위한 라이브러리 선택은 개발자의 몫입니다. 이러한 유연성과 확장성은 [리액트는 강력한 라이브러리로 만들었습니다.](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/)

최근까지도 상태 관리와 관련된 수많은 글과 라이브러리가 봇물처럼 쏟아지고 있습니다. 그러나 상태 관리가 왜 필요한지 원론적으로 설명해주는 글은 찾기 어려웠습니다. 리액트 내에서 컴포넌트 내부 상태를 관리하거나 리덕스(Redux) 모브엑스(MobX)와 같은 외부 라이브러리를 도입할 수 있습니다.

그러나 아직까지 상태 관리 라이브러리 별로 차이점과 장점을 속 시원하게 설명해주는 가이드는 없었습니다. 대다수는 상태 관리의 기본적인 한계와 문제점을 지적하지 않습니다. 최소한의 방법을 알려주기 보다 매우 과도한 방법으로 상태 관리를 해결하려 합니다. 사실 간단하게 해결할 수 있는데도 말이죠. 그동안 최신 애플리케이션 상태 관리를 일관되며 조직적으로 설계할 수 있는 실질적인 가이드가 필요하다고 생각했습니다. 이 것이 바로 제가 이 책을 쓴 이유입니다.

새로운 것을 배울 때 단계별로 차근차근 올라가는 것이 중요합니다. 반드시 한 문제를 해결한 후에 다음 문제로 넘어가세요. 모든 것을 한꺼번에 적용하지 마세요. 먼저 문제가 무엇인지 이해하고 해결하길 바랍니다. 이 책의 목적은 리액트 내 리덕스 사용법 뿐만 아니라 최신 애플리케이션 내 상태 관리에 대해 알려드립니다. 리덕스 개념과 활용법을 기술한 참고서를 넘어서 실제 실무에서 사용할 수 있는 내용을 담았습니다.

리액트 내부 상태 관리(Local State in React), 리덕스(Redux), 모브엑스(MobX)가 이 책의 주인공입니다. [댄 애브라몹(Dan Abramov)](https://twitter.com/dan_abramov), [앤드류 클라크(Andrew Clark)](https://twitter.com/acdlite), [마이클 웨스트레이트(Michel Weststrate)](https://twitter.com/mweststrate)와 같은 혁신가들이 없었다면 저는 이 책을 쓸 수 없었을 것입니다. 오늘날 최신 웹 개발을 즐겁게 할 수 있도록 공헌해주신 커뮤니티 내 모든 분들에게 감사의 말씀을 전합니다.